---
title: "First Estimates"
author: "Lucas Ramalho Anderson"
date: "21/10/2020"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE}
library ( dplyr )
library ( ggplot2 )

tempDir = "/scratch/genevol/users/lucas/"
saveDir = "/raid/genevol/users/lucas/heritability/plots/"
```
## Introduction


## Step 1

After the removal of monomorphisms, filtration of the desired samples and after obtaining the list of non-correlated genes per chromosome (considering correlation value of $\sqrt{0.1}$), it is now desired to calculate the GRM matrix.
```{r}
# Read file with all chromosomes
# allChrFile = SeqArray::seqOpen ( paste0 ( tempDir , "allChr.gds" ) )
# List of all genes of interest (after pruning)
listGenes = readRDS ( paste0 ( tempDir , "fullPrunedList.rds" ) )

# GRM - calculated as defined in CGTA
# grm_obj = SNPRelate::snpgdsGRM( allChrFile , snp.id = listGenes , method = "GCTA")

# Estimating through "gaston" package
altReadSnps = gaston::read.vcf( paste0 ( tempDir , "allChr.vcf.gz" ) )

# setting "p" parameter - correction with mean "p" and std sqrt(2p(1-2p))
gaston::standardize( altReadSnps ) <- "p"
grm_matrix = gaston::as.matrix ( altReadSnps )
# grm_scaled = scale( grm_matrix , center = T , scale = T )
# grm_scaled = readRDS (paste0(tempDir , "scaledMatrixBk.rds"))


# manual_GRM = ( 1 / nrow ( grm_scaled ) ) * grm_scaled %*% t ( grm_scaled )
# GRM matrix calculation (GCTA)
grm_alt_p = gaston::GRM ( altReadSnps , which.snps = listGenes )


# transform matrix into dataframe (3 columns - col1 = samples each row, col2 = samples each column ,  col3 = values for each pair)
dfGrm = reshape2::melt(grm_alt_p)

# indexing with numeric values each sample (columns and rows)
dfGrm$sampLines = rep ( seq ( 1 , nrow ( grm_alt_p ) ) , nrow ( grm_alt_p ) ) 
dfGrm$sampCols = sort ( rep ( seq ( 1 , nrow ( grm_alt_p ) ) , nrow ( grm_alt_p ) ) )


# To calculate the correlation between individuals, the calculation A_ij/sqrt(A_ii)sqrt(A_jj) will be done
# dataframe with only diag. values
dfGrmDiag = dfGrm[dfGrm$sampLines==dfGrm$sampCols,]
# sqrt of those values
dfGrmDiag = dfGrmDiag %>% mutate ( sqrtVal = sqrt ( value ) , sqrtVal2 = sqrt ( value ) )

# merging each A_ii for each row and col
dfGrmM = merge ( dfGrm , dfGrmDiag[ ,c ( "sqrtVal" , "sampLines" ) ] , on = c ( "sampLines" ) )
dfGrmM2 = merge ( dfGrmM , dfGrmDiag[ ,c ( "sqrtVal2" , "sampCols" ) ] , on = c ( "sampCols" ) )

# Calculating A_ij/(sqrt(A_ii)sqrt(A_jj))
dfGrmFinal = dfGrmM2 %>% mutate ( corrIndividuals = value / ( sqrtVal * sqrtVal2 ) ) %>% arrange ( Var1 , Var2 )

# plot heatmap - correlation between individuals
dfGrmFinal %>% ggplot( aes ( x = Var1 , y = Var2 , fill = corrIndividuals ) ) + 
geom_tile() +
theme( axis.text.x = element_text(angle = 90, hjust = 1) , text = element_text (size = 5) ) +
labs ( x = "Sample ID" , y = "Sample ID" )
# It seems there are blocks with higher correlation between individuals between the samples

# Filter of all correlation values between individuals
dfUniqueCorr = dfGrmFinal %>% filter ( corrIndividuals < .9999 ) %>% distinct ( corrIndividuals , .keep_all = TRUE)

# Histogram and density of correlation values
dfUniqueCorr %>% ggplot ( aes ( x = corrIndividuals ) ) +
geom_histogram ( aes(y=..density..) , bins = 100 ) +
geom_density ( ) +
labs ( x = "Correlation between individuals" , y = "Density" , title = "Histogram of correlation between distinct individuals" )
# The correlation blocks are bolder in this plot 

# Readind file with HLA expressions and ancestry information
hlaExp = readr::read_tsv("/raid/genevol/heritability/hla_expression.tsv")
# Ancestry of all samples
ancestry = unique ( hlaExp[ , c ( "subject_id" , "continental_pop" )] )

# Merging ancestry info with correlation dataframe
check = merge ( dfUniqueCorr , ancestry , by.x = c ( "Var1" ) , by.y = c ( "subject_id" ) )
check2 = merge ( check , ancestry , by.x = c ( "Var2" ) , by.y = c ( "subject_id" ) )

tableAncestry = unique ( check[,c("continental_pop" , "Var1")] ) %>% select ( continental_pop ) %>% table() %>% as.data.frame ( ) %>%  mutate ( relFreq = paste0 ( 100 * round ( Freq / sum ( Freq ) , 4 ) , "%") ) %>% rename ( "Ancestry" = "." )

knitr::kable( tableAncestry )
# Approximately 20% of the 444 individuals are African, while the other 80% are European



# Checking the amount of comparisons between individuals with same ancestry and different ones
checkFin = check2 %>% mutate ( ancestries = ifelse ( continental_pop.x == continental_pop.y , continental_pop.x , "Diff" ) )


tableComparisons = table ( checkFin$ancestries ) %>% as.data.frame() %>% mutate ( freqRel = Freq/ sum ( Freq ) ) %>% rename ( "Ancestry" = "Var1" , "NumComparisons" = "Freq" )

knitr::kable ( tableComparisons )

checkFin %>% ggplot ( aes ( x = corrIndividuals , fill =  ancestries ) ) +
geom_histogram ( aes(y=..density..) , bins = 10 ) +
geom_density ( ) +
facet_wrap ( ~ancestries ) +
theme(panel.spacing = unit (2, "lines") ) +
labs ( x = "Correlation between individuals" , y = "Density" , title = "Histogram of correlation between distinct individuals" )



# display individuals with correlation greater than 10% in the sample
listGreatCorr = checkFin[ ( checkFin$corrIndividuals > .1 ) & ( checkFin$corrIndividuals < .999 ) , ] %>% distinct( corrIndividuals , .keep_all = TRUE)

listGreatCorr
```

```{r}
grm = grm_alt_p
# rownames ( grm ) = altReadSnps
# colnames ( grm ) = altReadSnps$sample.id

eigenValuesGrm = eigen ( grm )
dfEigen = eigenValuesGrm$values %>% 
as.data.frame ( ) %>% 
mutate ( order = 1:n() ) %>%  
rename ( "Value" = '.' ) %>%  
mutate ( neg = ifelse ( Value < 0 , "Negative" , "Positive" ) )


dfEigen %>% ggplot ( aes ( x = order , y = Value , colour = neg )  ) + 
geom_point ( ) +
labs ( x = "Order" , y = "Eigen Value" , title = "Eigen values plot" , colour = "Sign" )

matrixCorrection = eigenValuesGrm$vectors %*% diag( eigenValuesGrm$values + abs ( min ( eigenValuesGrm$values ) ) ) %*% t ( eigenValuesGrm$vectors )
# rownames ( matrixCorrection ) = grm_obj$sample.id
# colnames ( matrixCorrection ) = grm_obj$sample.id

rownames ( matrixCorrection ) = rownames ( grm )
colnames ( matrixCorrection ) = colnames ( grm )


eigenCorr = eigen ( matrixCorrection )

dfEigenCorr = eigenCorr$values %>% 
  as.data.frame ( ) %>% 
  mutate ( order = 1:n() ) %>%  
  rename ( "Value" = '.' ) %>%  
  mutate ( neg = ifelse ( Value < 0 , "Negative" , "Positive" ) )


dfEigenCorr %>% ggplot ( aes ( x = order , y = Value , colour = neg )  ) + 
  geom_point ( ) +
  labs ( x = "Order" , y = "Eigen Value" , title = "Eigen values plot" , colour = "Sign" )

```

```{r}
expressionInterest = hlaExp %>% filter ( subject_id %in% colnames ( grm ) )

mainInfo = expressionInterest %>% distinct( subject_id , continental_pop ,population )
numEigen = 2
print ( paste0 ( "Total variation explained by the first ", numEigen , " eigen values: " , 100*round ( sum ( eigenCorr$values[1:numEigen] )/ sum ( eigenCorr$values ) , 4 ) , "%" ) )
vectors_ = eigenCorr$vectors[,1:numEigen]
calcScores = matrixCorrection %*% vectors_ %>% 
  as.data.frame() %>% 
  rename ( "PC1" = "V1" , "PC2" = "V2" ) %>% 
  mutate ( subject_id = rownames ( matrixCorrection ) )
pcaPlot = merge ( mainInfo , calcScores )

pcaPlot %>% ggplot ( aes ( x = PC1 , y = PC2  , colour = continental_pop ) ) +
  geom_point ( ) +
  labs ( title = "PCA plot (first 2 dimensions)" , colour = "Origin" )
  # geom_text ( )

```


```{r}
simpleModels = function ( exp_ , df ){
  
  dfFilter = df  %>% filter ( gene_name == exp_ )
  
  fixed0 = lm ( TPM ~ 1 , data = dfFilter )
  sum0 = summary ( fixed0 )
  fixedEffectSigma = sum0$sigma^2

  mixedModel = coxme::lmekin( dfFilter$TPM ~ 1 + (1|dfFilter$subject_id) , data=dfFilter, varlist=list(matrixCorrection), vinit=2)
  
  mixedEffectSigma = mixedModel$sigma^2
  sigmaA = as.numeric(mixedModel$vcoef)
  
  # comparison = mixedEffectSigma/fixedEffectSigma
  
  # h = sigmaA / ( sigmaA + mixedEffectSigma)
  
  
  modelExpanded = coxme::lmekin( dfFilter$TPM ~ 1 + dfFilter$PC1 + dfFilter$PC2 + (1|dfFilter$subject_id), data=dfFilter, varlist=list(matrixCorrection), vinit=2)

  mixedEffectSigmaExp <- modelExpanded$sigma^2
  # comparisonExp = modelExpanded/fixedEffectSigma
  sigmaAExp = as.numeric(modelExpanded$vcoef)
  
  # hExp = sigmaAExp / (sigmaAExp + mixedEffectSigmaExp )
  
  return ( c ( exp_ , fixedEffectSigma , mixedEffectSigma , sigmaA , mixedEffectSigmaExp , sigmaAExp ) )
  
}

listNames = unique ( expressionInterest$gene_name )
modelDf = merge ( expressionInterest , calcScores )

requiredInfo = NULL
for ( name_ in listNames ){
  
  requiredInfo = rbind ( requiredInfo , simpleModels ( exp_ = name_ ,df = modelDf ) )
  
}

finalDf = requiredInfo %>% as.data.frame ( ) %>% rename ("Gene" = "V1" , 
                                                          "fixedSigma" = "V2" ,
                                                          "residualMixedSigma" = "V3" , 
                                                          "randomEffectSigma" = "V4",
                                                          "residualMixedSigmaExp" = "V5" ,
                                                          "randomEffectSigmaExp" = "V6") %>%
mutate ( fixedSigma = as.numeric ( as.character ( fixedSigma ) ) ,
	residualMixedSigma = as.numeric ( as.character (residualMixedSigma)) ,
	randomEffectSigma =  as.numeric ( as.character (randomEffectSigma)) ,
	residualMixedSigmaExp = as.numeric ( as.character (residualMixedSigmaExp)),
	randomEffectSigmaExp = as.numeric ( as.character (randomEffectSigmaExp))
	) %>%
  mutate ( comparisonNull = residualMixedSigma/fixedSigma , 
           comparisonNullExp = residualMixedSigmaExp/fixedSigma ,
           hSimple = randomEffectSigma / ( randomEffectSigma + residualMixedSigma ) ,
           hExpanded = randomEffectSigmaExp / ( randomEffectSigmaExp + residualMixedSigmaExp ))

finalDf %>% knitr::kable()
```
